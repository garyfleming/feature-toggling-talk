<!DOCTYPE HTML>
<html>
<head>
	<title>Feature Toggling - Gary Fleming</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=1274, user-scalable=no">
	<link rel="stylesheet" href="style.css">	
	<link href='http://fonts.googleapis.com/css?family=Rambla' rel='stylesheet' type='text/css'>
	<style>
	    p {font-family: 'Rambla', sans-serif;}
		h2 { text-align:center;	font-size:70px; font-family: 'Rambla', sans-serif;	}		
        p.small {font-size:75%}
	</style>
</head>
<body class="list">
	<header class="caption"><h1>Feature Toggling</h1><p>Gary Fleming</p></header>
	
	<div class="slide" id="talkstart"><div><section><header><h1>Feature Toggling</h1><h3>An Alternative to Branching</h3><p>Gary Fleming <p>@garyfleming</p></header></section></div></div>
	<!-- 
	Hello, my name is Gary Fleming and I'm going to talk to you today about feature toggling. While this talk is mainly aimed at developers in medium to large projects, there are useful points in here for product managers and owners too..
	
	OR
	
	As a developer or project manager, it's not always easy to ensure that multiple features for a project can be built separately. Branching has long been a favoured technique when managing parallel development, but comes at a cost. In this talk, we'll see what that cost is and explore a better alternative. (Hint: it's feature-toggling)
	-->
	
	<div class="slide " id="talk1"><div><section><header><h2>VCS</h2></header>
		<ul><li>You know what it is,</li>
			<li>Traditional</li>
			<li>Not-distributed</ul>
	</section></div></div>	
	<!-- 
For much of this talk I'm going to assume that:
* you know what version control is,
* you're using a traditional version control system like Subversion or Perforce,
If you're using distributed system like Git, these lessons still apply, but with slight tweaks.
	-->
	
	<div class="slide " id="talk2"><div><section><header><h2>The Problem</h2></header></section></div></div>	
	<!-- 
	Imagine that you and your team have been asked to deliver several new features to your online store: the payment provider is being replaced; the user profile section is being integrated with some social media site; and the recommendation system is being tweaked. All these features are separate, but there are some shared points in the code.	
	-->
	
	<div class="slide " id="talk3"><div><section><header><h2>Release when?</h2></header></section></div></div>	
	<!-- 
	The other part of the problem is that you don't know yet in which order these will be finished, so you don't know which one will go live first. That is, you need to be prepared for any of them to be live before the other ones. This leads to some interesting problems in arranging how you work together without conflicting. What's the solution?
	
	-->
	
	<div class="slide " id="talk4"><div><section><header><h2>Continuous Integration - What?</h2></header></section></div></div>	
	<!-- 
	Before that, an important tangent: What is continuous integration? Broadly speaking it's the notion that when we're working with other developers in a team it's a very good idea to bring our work together frequently so that we know that we're all still aiming for the same goal, without the potential for too many conflicts and issues along the way.
	
	-->
	
	<div class="slide " id="talk5"><div><section><header><h2>Continuous Integration - Four Steps</h2></header>
		<ul><li>Update,</li>
			<li>Fix</li></section></div></div>	
	<!-- 
	To do, continuous integration well we do four things:
	* Before checking in to version control, we need to take everyone else's updates from trunk.
	* We need to fix any issues we see before we commit our changes. It is therefore _always_ the responsibility of those who are making a change to ensure they work.
	
	-->
	
	<div class="slide " id="talk6"><div><section><header><h2>Continuous Integration - Four Steps (pt. 2)</h2></header>
		<ul><li>Commit,</li>
			<li>Automate</li></section></div></div>	
	<!-- 
	* To ensure the continuous part, we commit frequently - at least once per day, preferably more often. I often commit safely multiple times an hour. When I can't do commit at least once an hour, it's often a sign that I'm working on something too big.
	* Finally, we run our build autonomously on a separate machine, so that we know everything works somewhere other than our own machine. This helps find issues.
	
	-->
	
	<div class="slide " id="talk7"><div><section><header><h2>Continuous Integration - Three Prerequisites</h2></header>
		<ul><li>Test existing behaviour,</li>
			<li>Test new behaviour</li>
			<li>Reliable, fast builds</ul></section></div></div>	
	<!-- 
	To make those tasks possible we need to ensure three other things are always true:
	* Any behaviour we want our system to exhibit MUST have a test, so we can ensure that behaviour remains.
	* Any new behaviour we want our system to exhibit MUST also have a test, so we can ensure that behaviour remains in the future.
	* Our build as a whole must be fast and reliable. No-one will check the build is working before committing if that takes hours or may not work for reasons outwith their control.
	
	-->
	
	<div class="slide " id="talk8"><div><section><header><h2>Continuous Integration - Why?</h2></header>
		<ul><li>Communication,</li>
		<li>No Conflict</li>
		<li>No Rework</ul></section></div></div>	
	<!-- 
	Why do we do all this? Because continuous integration is a definitive and relatively unambiguous way for teams to communicate. If you use Continuous integration, you know immediately when your changes are causing a problem for some else and vice versa; as opposed to finding out weeks or months later. Find problems early is much better than finding them later and have to rework.
	
	-->
	
	<div class="slide" id="talk9"><div><section><header><h2>Feature-Branching - The Idea</h2></header></section></div></div>	
	<!-- 
	 Now back to solving our problem of trying to deliver multiple features: one solution is called Feature-Branching, or sometimes just branching. The idea here is that for every feature that you want to deliver, you create a new branch in your version control system. All work for that feature is then done exclusively on that branch, and any changes on trunk are merged onto the branch (usually in branches, periodically).
	
	
	
	-->
	
	<div class="slide " id="talk10"><div><section><header><h2>Feature Branching - Isolation</h2></header></section></div></div>	
	<!-- 
	When a feature is complete, to release it, you just merge the branch back into your trunk, and the feature is there and is ready to be used. While developing it's been completely isolated so you know that it can't cause you any conflicts while it is on its own branch.
	
	-->
	
	<div class="slide " id="talk11"><div><section><header><h2>Feature Branching - Release</h2></header></section></div></div>	
	<!-- 
	That's really nice because it lets you cherry-pick the features you want to release simply by controlling what you allow into your trunk. If you don't want to release it yet, well, leave it on the branch a bit longer. It also means that you can have as many parallel features in progress as branches, which surely is a good thing?
	
	-->
	
	<div class="slide " id="talk12"><div><section><header><h2>Feature Branching is Anti-CI</h2></header></section></div></div>	
	<!-- 
	Well, no. Because if you're doing feature branching, you're not doing continuous integration and getting the benefits of doing that. Every branch is now spending weeks or months separate from the trunk, i.e not integrated, and the potential for conflicts increases rapidly with every day and every branch. You're no longer communicating.
	
	-->
	
	<div class="slide " id="talk13"><div><section><header><h2>Feature Branching - Manual Merging</h2></header></section></div></div>	
	<!-- 
	[good point, but poorly made. Fix this.]Merging is also error-prone and manual. Because you're relying on people to bring together disparate threads of your system months after they're finished, they have to reason about multiple things that they may not have seen and may not fully understand.
	
	-->
	
	<div class="slide " id="talk14"><div><section><header><h2>Feature Branching - Summary</h2></header></section></div></div>	
	<!-- 
	Dan Bardot said: "Feature Branching is a poor man's modular architecture, instead of building systems with the ability to easily swap in and out features at runtime/deploytime they couple themselves to the source control providing this mechanism through manual merging."
	Bardot is hinting at our alternative: Feature Toggling.
	-->
	
	<div class="slide " id="talk15"><div><section><header><h2>Feature Toggling - A New Hope?</h2></header></section></div></div>	
	<!-- 
	I've spent most of my time not talking about the subject so I guess I should fix that: by telling you what we don't do when feature toggling. We don't branch. All development happens on trunk, and never on a branch. That means we've immediately regained our continuous integration.
	-->
	
	<div class="slide " id="talk16"><div><section><header><h2>Feature Toggling - Isolation</h2></header></section></div></div>	
	<!-- 
	The sharper minded amongst you are thinking, "Sure, you get continuous integration, but what about isolation? How do you develop features together safely?" That's the toggle part. For every piece of code that is either a work in progress or not ready to go live yet, you introduce an abstraction that hides away your implementation changes. You then build a mechanism, a toggle, that lets you switch between different implementations.
	
	-->
	
	<div class="slide " id="talk17"><div><section><header><h2>Feature Toggling - Additions</h2></header></section></div></div>	
	<!-- 
	What that looks like: for an a new piece of functionality, it's very straightforward. Your toggle is going to be an on/off state. If the toggle is on, your new feature is included in the runtime. If it's off, it's not. So you can develop something on trunk that may or may not be ready for production yet.
	
	-->
	
	<div class="slide " id="talk18"><div><section><header><h2>Feature Toggling - Modification</h2></header></section></div></div>	
	<!-- 
		For modifications, it's not that much harder: you take the existing version of the code and put an abstraction in front of it that provides a nice interface to both the new and old versions of your code. You then make all of your existing code use that interface. You write the new implementation, and have the toggle switch between the new and old at will.
	-->
	
	<div class="slide " id="talk20"><div><section><header><h2>Feature Toggling - Summary</h2></header></section></div></div>	
	<!-- 
	Think about what this achieves: all of your team can work together and see exactly what's coming down the line in a way that is safe. If conflicts arise you know about them immediately and can resolve them before rework becomes painful, and you can keep changes isolated as long as you need. Compare that to the alternatives, and it's a clear advantage. Thank you.
	-->
	


	<script src="script.js"></script>	
</body>
</html>
